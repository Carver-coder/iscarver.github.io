[{"categories":["算法"],"content":"\r关于时间空间复杂度，只需要记住如下几点：\r时间空间复杂度用大写的O来表示（例如：O(1),O(n²)等等）。在我们进行时间空间复杂度的计算时，我们不需要明确计算，常数项和低增长项都可以忽略，只需要估算并且保留最高增长项。 时间复杂度用来衡量一个算法的执行效率，时空复杂度用来衡量算法的内存消耗，他们都是越小越好。 ","date":"2025-05-07","objectID":"/%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%9F%BA%E7%A1%80/:0:0","tags":["算法"],"title":"时间空间复杂度基础","uri":"/%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%9F%BA%E7%A1%80/"},{"categories":["算法"],"content":"时间空间复杂度： 怎样进行估算？ 现在可以进行简单的理解：时间复杂度大部分情况下就是看for循环的最大嵌套层数 总执行次数T(n)是不是常数项： 是：时间复杂度为O(1) 否：时间复杂度为O(保留最高增长项，并去除最高次项的系数) 示例： 时间复杂度O(1) 空间复杂度：O(1) void function(void) { printf(\"H\"); printf(\"e\"); printf(\"l\"); printf(\"l\"); printf(\"o\"); }\r时间复杂度O(n) 空间复杂度：O(1) void function(int n) { for (int i = 0; i \u003c n; i ++ ) { printf(\"1\"); } }\r时间复杂度O(n²) 空间复杂度：O(1) void function(int n) { for (int i = 0; i \u003c n; i ++ ) { for (int j = 0; j \u003c n; j ++ ) { printf(\"1\"); } } }\r在函数内，最里面的循环执行为n+1次，约等于n次。外面的循环约等于运行了n次。所以运行时间为：O(n²) 有几层循环嵌套就是n的多少次方 时间复杂度O(n) 空间复杂度：O(n) void function(int n) { vector\u003cint\u003e nums(n); }\r这个函数中创建了一个大小为 n 的数组，所以空间复杂度是 O(n)。 时间复杂度不仅仅体现在我们所看到的for循环内，每一行代码都可能对计算时间复杂度做出更改。所以要了解编程语言提供的常用数据结构实现原理，这是准确分析复杂度的基础。 时间复杂度排序： O(1) \u003c O(logn) \u003c O(n) \u003c O(nlogn) \u003c O(n²) \u003c O(n^3) \u003c O(2^n) ","date":"2025-05-07","objectID":"/%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%9F%BA%E7%A1%80/:0:1","tags":["算法"],"title":"时间空间复杂度基础","uri":"/%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%9F%BA%E7%A1%80/"},{"categories":[""],"content":"这是一个测试！！！ ","date":"2025-05-06","objectID":"/test/:0:0","tags":[""],"title":"Test","uri":"/test/"}]